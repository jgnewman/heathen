```
 _____ ______ ________   _______     ___________   _____  _____  _________  _____     _____
|   // |   //|       // /      \\   |           | ||   / ||   / ||       / ||    \   ||   /
|  ||  |  || |   ___// /   //\  \\  | ___   ___ | ||  |  ||  |  ||   ___/  ||     \  ||  |
|  ||  |  || |  ||     |  ||  |  || |// |   | \\| ||  |  ||  |  ||  |      ||  |   \ ||  |
|  ----/  || |  |---// |  ----/  ||     |   |     ||  ----/  |  ||   ---/  ||  |\   \||  |
|  ____   || |   __//  |   ___   ||     |   |     ||  ____   |  ||   __/   ||  |\\   \|  |
|  ||  |  || |  ||     |  ||  |  ||     |   |     ||  |  ||  |  ||  |      ||  | \\   \  |
|  ||  |  || |  |----//|  ||  |  ||     |   |     ||  |  ||  |  ||   ----/ ||  |  \\     |
|___\\ |___\\|______// |___\\ |___\\    /___\     ||___\ ||___\ ||______/  ||___\  \\_____\

--------------------- An Object-Oriented Lisp Dialect for JavaScript ----------------------

```

### Why create another language targeting JavaScript?

I believe variety is good.  There are some unique ideas in Heathen you won't find anywhere
else and, while I don't demand that everyone use Heathen instead of other tools, I do
hope folks will at least experiment and maybe some of my these ideas will be carried into
the future.

### What are some of the advantages?

The JavaScript code generated by Heathen is extremely accessible. It's composed completely
of "good parts" with no "bad parts" and is very nice and clean.  Heathen is almost more
like a preprocessor than a new language in some ways... except it's made up
almost entirely of S expressions.

This, of course, brings me to my next point:  If you've ever been intrigued by languages
like Lisp, Scheme, or Clojure, Heathen can help you familiarize yourself with S expression
dialect without forcing you to program fully in the functional paradigm.  After all,
JavaScript doesn't incorporate tail call optimization so we can't very well do _everything_
with recursion, can we?

Heathen also gives you simple pattern-match syntax, super simple extensible classes, and,
perhaps most interesting of all, the ability to specify which parameters you'd like to
attach arguments to when you make a function call with `-flags` like you have in Bash.

### Haven't you ever heard of ClojureScript?

Haha, of course I have :)  This is not even remotely the same thing.  ClojureScript is awesome
and does a _lot_ of awesome stuff.  However, ClojureScript is also a _lot_ heavier than Heathen
and the generated code is far less accessible given the fact that you have all those different
kinds of data structures and whatnot.

Heathen does not attempt to implement the functional paradigm over JavaScript so you get to
keep things like variable reassignment.  As a result, the generated code is smaller and
easier for someone looking at it to figure out and debug.  It's a different tool for
different kinds of jobs.

### How do I get started?

Installation
------------

Heathen is an npm package so, provided you already have Node.js and npm, just do one
of these from the command line:

```bash
~$ npm install heathen
```

Or, if you want to install globally:

```bash
~$ npm install heathen -g
```

Usage
-----

The first thing you should know is that Heathen files end with `.hn` or `.heathen`.  I've included
a `.tmLanguage` file you can use for your TextMate-compatible editors in the `/highlighting` directory.

Using Heathen via the command line or as a Node module is easy.  From the command line, here are your
options:

```bash
Usage: heathen [input] [options]

Input: The path to the file containing Heathen code.

Options:

  -v, --version          Display the version of heathen.
  -h, --help             Display help information.
  -o, --output [file]    The path to the file where you want to place compiled code.
  -m, --minify

```

So obviously calling `heathen -v` or `heathen -h` will respectively give you the current version and
the help options.

Other than that, you can simply pass it a path specifying an input file.  If you don't specify an
output file with the `-o` flag, Heathen will output compiled code to the std out.  If you do
specify an output file, it will asynchronously write code to that file.  Heathen will minify
your code if you tell it to with the `-m` flag but, if not, it will come out nicely spaced and indented.

If you want to use Heathen with Node, you have a similar API.  First you'll have to require the
module, of course:

```javascript
var heathen = require('heathen');
```

Then you can call it and pass in an object specifying how to compile.  For, example:

```javascript
heathen.compile({
  input    : './rawcode.hn',
  output   : './compiledcode.js',
  minify   : true,
  callback : function (err) {
    ...whatever...
  }
});
```

The above example will take the raw code from `./rawcode.hn`, compile it, minify it, and write it
asynchronously to `./compiledcode.js`.  Then, afterward, it will run the callback with any possible
error as an argument.

If you don't specify the `minify` property, the code will be beautified instead.  If you don't
specify the `output` property, the output will go to the console.  If you don't specify
the `input` property, you'll end up with an empty JavaScript module.

Syntax
------

Here are a few examples of Heathen syntax.  To learn more, read the [docs](http://www.example.com).
